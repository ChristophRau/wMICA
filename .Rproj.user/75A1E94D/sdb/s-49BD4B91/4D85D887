{
    "collab_server" : "",
    "contents" : "library(igraph)\nx=100\ntemp=barabasi.game(x,power = 3)\nnetwork=get.edgelist(temp)\nweights=c(runif(n=nrow(network),min = .4,max = 1))\nnetwork=cbind(network,weights)\n\nL=network\nNiter=10000\nN=nrow(network)\nM=x\nLindices=sample(N)\nC=10\nalpha=10\nbeta=.01\nq=matrix(0,C,M)\nncores=4\n\n\nz <- sample(1:C, N, replace=TRUE)\nn <- as.vector(table(factor(z, levels=1:C)))\nfor (l in 1:N) {\n  q[z[l], L[l,1]] <- q[z[l], L[l,1]]+L[l,3]\n  q[z[l], L[l,2]] <- q[z[l], L[l,2]]+L[l,3]li\n}\nconv <- vector(\"numeric\",M)\nq_orig=q\n\n\nOrigMICA<-  function(L, Niter, N, M, Lindices,\n           C, z, q, n, alpha, beta, conv) {\n    ## Main iteration loop\n    date()\n    for (s in 1:Niter) {\n      cat(\".\")\n      ## Sample new component for each link\n      for (li in 1:N) {\n\n        l = Lindices[li]\n        i = L[l,1]\n        j = L[l,2]\n        weight=L[l,3]\n\n        ## Subtract the contribution of the link from the counts\n        q[z[l],i] <- q[z[l],i]-weight\n        q[z[l],j] <- q[z[l],j]-weight\n        n[z[l]] <- n[z[l]]-1\n\n        ## Loop for computing probabilities for the components to be sampled\n        uz <- vector(\"numeric\", C)\n        for (p in 1:C) {\n          A <- (n[p] +alpha)\n          B <- (q[p,i] +beta)*(q[p,j] +beta) / ((2*n[p] +1 +M*beta)*(2*n[p] +M*beta))\n          uz[p] <- A *B\n        }\n\n        ## Draw a new component for the links and update the counts */\n        newz <- ICMg.multinom.single(uz)\n        conv[l] <- uz[newz]/sum(uz)\n        n[newz] <- n[newz]+1\n        q[newz,i] <- q[newz,i]+weight\n        q[newz,j] <- q[newz,j]+weight\n        z[l] <- newz\n      }\n    }\n  date()\n    cat(\"\\n\")\n    return(list(z=z, q=q, n=n, conv=conv))\n  }\n\n\n####MICA APPLY WORKHORSE FUNCTION####\n  MAWorkhorse <-function(l){\n    i = L[l,1]\n    j = L[l,2]\n    weight=L[l,3]\n    q[z[l],i] <<- q[z[l],i]-weight\n    q[z[l],j] <<- q[z[l],j]-weight\n    n[z[l]] <<- n[z[l]]-1\n\n    ## Loop for computing probabilities for the components to be sampled\n    uz <- vector(\"numeric\", C)\n    for (p in 1:C) {\n      A <- (n[p] +alpha)\n      B <- (q[p,i] +beta)*(q[p,j] +beta) / ((2*n[p] +1 +M*beta)*(2*n[p] +M*beta))\n      uz[p] <- A *B\n    }\n    newz <- ICMg.multinom.single(uz)\n    conv[l] <<- uz[newz]/sum(uz)\n    n[newz] <<- n[newz]+1\n    q[newz,i] <<- q[newz,i]+weight\n    q[newz,j] <<- q[newz,j]+weight\n    z[l] <<- newz\n  }\n\nMICA_Apply<-  function(L, Niter, N, M, Lindices,\n                     C, z, q, n, alpha, beta, conv) {\n  ## Main iteration loop\n  date()\n  for (s in 1:Niter) {\n    cat(\".\")\n    ## Sample new component for each link\n    temp=sapply(Lindices,MAWorkhorse)\n  }\n  date()\n\n  cat(\"\\n\")\n  return(list(z=z, q=q, n=n, conv=conv))\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMAPWorkhorse <-function(l){\n  i = L[l,1]\n  j = L[l,2]\n  weight=L[l,3]\n  q[z[l],i] <- q[z[l],i]-weight\n  q[z[l],j] <- q[z[l],j]-weight\n  n[z[l]] <- n[z[l]]-1\n  q_new=array(0,dim=dim(q))\n  n_new=rep(0,length(n))\n  conv_new=rep(0,length(conv))\n  z_new=rep(0,length(z))\n\n  ## Loop for computing probabilities for the components to be sampled\n  uz <- vector(\"numeric\", C)\n  for (p in 1:C) {\n    A <- (n[p] +alpha)\n    B <- (q[p,i] +beta)*(q[p,j] +beta) / ((2*n[p] +1 +M*beta)*(2*n[p] +M*beta))\n    uz[p] <- A *B\n  }\n  newz <- ICMg.multinom.single(uz)\n  conv_new[l] <- uz[newz]/sum(uz)\n  n_new[newz] <- n[newz]+1\n  q_new[newz,i] <- q[newz,i]+weight\n  q_new[newz,j] <- q[newz,j]+weight\n  z_new[l] <- newz\n  return(list(n=n_new,q=q_new,z=z_new,conv=conv_new))\n}\n\n\n\n\nlibrary(foreach)\nlibrary(doParallel)\nMICA_Par<-  function(L, Niter, N, M, Lindices,\n                       C, z, q, n, alpha, beta, conv,ncores) {\n  ## Main iteration loop\n  date()\n  for (s in 1:Niter) {\n    cat(\".\")\n    ## Sample new component for each link\n    c1<-makeCluster(ncores-1)\n    clusterExport(c1,c(\"L\",\"Niter\",\"N\",\"M\",\"C\",\"z\",\"q\",\"n\",\"alpha\",\"beta\",\n                       \"conv\",\"ICMg.multinom.single\"))\n    this_out=parLapply(c1,Lindices,MAPWorkhorse)\n    stopCluster(c1)\n\n    q=array(0,dim=dim(q))\n    n=rep(0,length(n))\n    conv=rep(0,length(conv))\n    z=rep(0,length(z))\n\n    for(i in 1:length(Lindices)){\n      q=q_new+this_out[[i]]$q\n      n=n_new+this_out[[i]]$n\n      conv=conv_new+this_out[[i]]$conv\n      z=z_new+this_out[[i]]$z\n    }\n  }\n\n\n\n\n  cat(\"\\n\")\n  return(list(z=z, q=q, n=n, conv=conv))\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1500958395746.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2562146164",
    "id" : "4D85D887",
    "lastKnownWriteTime" : 1501015989,
    "last_content_update" : 1501017630639,
    "path" : "C:/Work/8 - Code/wMICA/MICARedo.R",
    "project_path" : "MICARedo.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}